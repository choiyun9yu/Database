트랜잭션 : DB에서 작업단위, 일괄처리의 기준

커밋 : 트랜잭션이 정상적으로 수행되었을 시 트랜잭션의 수행내용 전체를 한 번에 물리적으로 DB에 저장

롤백 : 트랜잭션이 비정상적으로 수행되었을 시 이전 커밋(save point) 시점으로 되돌아 감

DML (insert / update / delete)는 3개 가 다 합쳐져서 트랜잭션 1개 (이거한다음에 반드시 커밋을 해줘야함)

DCL (create/ ) 하나 하나가 다 개별 트랜잭션 1개

오토커밋 ( 이전 트랜잭션이 완료되지 않아도 다음 트랜잭션이 시작하면 자동으로 커밋됨)

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------insert 

	insert into 테이블명(컬럼명)  <- 컬럼명은 안적으면 모든 컬럼 개수 맞춰서 적어야하고 컬럼명 적으면 컬럼명 개수만큼 컬럼값 적어야함
	values (각 칼럼에 해당 값)

컬럼무결성 : 데이터 타입이 맞아야 데이터가 삽입이 됨

!! 다른 테이블에서 행 복사 삽입 !!
	insert into 테이블명 selec문       <- 주의, 인설트 절의 열 수와 서브쿼리문의 열수를 일치시켜야한다. (select 문이 서브쿼리문)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
update 
	
	update 테이블명
	set 칼럼명 = 데이터
	(where department_id = 70) <- 웨어 안쓰면 전체 바뀌니까 웬만하면 적기

       병행제어
	-로킹
	-타임스탬프
	-낙관적 병행제어
	-다중버전 병행제어
	  (연쇄복귀?) : 두개 이상의 Transaction이 수행되던중 한개의 Transaction이 취소될 때 나머지 다른 Transaction도 연쇄적으로 취소되는 현상
	  두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생
	  한 트랜잭션이 데이터를 갱신한 다음 실패하여 Rollback 연산을 수행하는 과정에서 갱신과 Rollback 연산을 실행하고 있는 사이에 
	  해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제
	  같은 자원을 사용하는 두개의 트랜잭션 중 한 개의 트랜잭션이 성공적으로 일을 수행하였다 하더라도 
	  다른 트랜잭션이 처리하는 과정에서 실패하게 되면 두 개의 트랜잭션 모두가 복귀되는 현상

	update employees set salary = (select max(salary) from employees where department_id = 50) where department_id = 70;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
delete

	delete (from) 테이블명 <- from은 생략가능
	(where department_id = 270;)   <- 웨어 안쓰면 전체 바뀌니까 웬만하면 적기

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

















