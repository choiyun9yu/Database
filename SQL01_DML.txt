# 계정 관리
	# 로그인
		- mysql : MYSQL -h(호스트명) -u(계정명) -p(비밀번호) 
		- oracle : SQLPLUS (enter)
				USER-NAME : sys as sysdba (enter)
				PASSWORD : (enter, enter)

	# 계정 확인
		- mysql : USE MYSQL; 
				  SHOW TABLES;
				  SELECT HOST, USER,PASSWORD FORM USER;
		- oracle : SELECT * FROM ALL_USERS;

	# 계정 생성
		- mysql : CREATE USER (계정명)@(접속위치) 
				  IDENTIFITED BY (비밀번호);
		- oracle : CREATE USER (계정명) 
				   IDENTIFIED BY (비밀번호);

	# 권한 부여
		- mysql : GRANGT ALL PRIVILEGES ON (DB명).* TO (계정명)@(접속위치) 
				  IDENTIFITED BY 비밀번호;
		- oracle : GRANT CONNECT, RESOURCE, DBA TO (계정명);
				   COMMIT;

	# 계정 삭제
		- mysql : DROP USER (계정명)@(접속위치);
		- oracle : DROP DATABASE (DB명); 

	# 계정 연결
		- mysql : 
		- oracle : conn 유저/비번;  ex)hr/hr

	# 언락(시스템 계정에서)
		- oracle : ALTER USER USER (계정명) ACCOUNT UNLOCK
				   IDENTIFITED BY (비밀번호) // 비밀번호 바꾸는 것
----------------------------------------------------------------------------------------------------------

# 데이터베이스 관리 
	# 데이터베이스 조회
		- mysql : SHOW DATABASES;
		- oracle : 

	# 데이터베이스 생성
		- mysql : CRATE DATABASE (DB명);
		- oracle : 

	# 데이터베이스 삭제
		- mysql : DROP DATABASE (DB명);
		- oracle : 

	# 데이터베이스 접속
		- mysql : USE DB;
		- oracle : 
----------------------------------------------------------------------------------------------------------

# 테이블 관리
	# 테이블 목록 조회
		- mysql : SHOW TABLES;
		- oracle : SELECT * FROM TAB;

	# 테이블 스키마 조회
		- DESC (테이블명);
	
	# 테이블 출력 길이 조절
		- COLUMN (컬럼명) FORMAT (A20);
----------------------------------------------------------------------------------------------------------

# 메모장으로 쿼리문 작성하기!
	- ed (enter);  // 메모장이 뜨면서 이전이 입력한 쿼리문이 뜸 ('/'가 ';'역하을 대신함) (ctrl+s)저장하고,
	  / (enter)    // 커멘드 창에서 / 엔터하면 메모장에 저장한 내용의 쿼리문이 실행된다.
----------------------------------------------------------------------------------------------------------

# SELECT 문
	SELECT (조회할 칼럼)
	FROM (조회할 테이블)
	WHERE (조회 조건)
	GROUBP BY ('00별'로 묶을 칼럼)
	HAVING (그룹 바이의 조건)
	ORDER BY (정렬 조건)

	# SELECT
		SELECT (칼럼명) FROM (테이블명);

		// 명령문이나 절 뒤에 숫자가 나오면 데이터로 인식하고, 문자가 오면 컬럼명으로 인식한다.
	 	   문자나 날짜 취급을 받고 싶으면 ''로 묶어줘야 한다.

	# 별칭설정 : AS
		SELECT (칼럼명) AS '(별칭)' FROM (테이블명);  // ""로 묵으면 대문자 소분자 포맷 그대로 출력!!

	# 중복제거 : DISTINCT
		SELECT DISTINCT (칼럼명) FORM (테이블명);

	# 연결연산자로 'str' 삽입 : || 
		SELECT (칼럼명1) || 'str' || (칼럼명2) FROM (테이블명);
		>> 칼러명1 str 칼럼명2 
----------------------------------------------------------------------------------------------------------

# 연산자
----------------------------------------------------------------------------------------------------------

# WHERE
----------------------------------------------------------------------------------------------------------

# GROUBP BY
----------------------------------------------------------------------------------------------------------

# ORDER BY
----------------------------------------------------------------------------------------------------------

# LIMMIT
----------------------------------------------------------------------------------------------------------

	#연결 연산자 : ||      ( 연결할컬럼1||연결할컬럼2 )


	#연결 연산자로 스트링 삽입 
	SELECT last_name||'is a'||job_id     (연결할칼럼1||'str'||연결할칼럼2) 
	FROM employees;

						명령문 다음에 숫자가 오면 데이터로, 문자가 오면 컬럼명으로 인식한다. 문자이거나 날짜 취급하고 싶으면 ' ' 로 묶음.


	#중복제거 destinct
	(ex) select distinct department_id from employees;


	# select 에서 카운트 함수
	(ex) select count(distinct department_id) from employees;	
	
	
----------------------------------------------------------------------------------------------------------
	#where 조건 절 

		select last_name, 12*salary as annsal from employees where 12*salary >= 120000; 됨
		select last_name, 12*salary as annsal from employees where annsal >= 120000;  안됨
		// 안되는 이유 from절 -> where절 -> select절 -> order by 그래서 select절 별칭을 where절에서 인지 불가능, order by에선 사용 가능!!!

		# 사원 번호가 176인 사원의 성과 부서번호 추력
		select last_name, department_id from employees where employee_id =176 <- 이게 답 (어짜피 프롬다음 웨어하니까 컬럼에서 안가져와도 됨)
		select employee_id, last_name, department_id from employees where employee_id =176  <-이건 3개 출력 

		#비교연산자
		단일연산자
		<> 같지않음
		!= 같지않음
		= 같음

		#비교조건연산자
		(1) between A and B  // a는 하한 B는 상한
		(ex) select last_name, salary from employees where salary between 5000 and 7000;

		(2) in 연산자 : where 절 내에서 특정값 여러개 선택하는 sql 연산자 
		(ex)select manager_id, employee_id, last_name from employees where manager_id in ('100', '101', '102');

		(3) like 연산자 : 문자패턴이 같은?
		(ex) select last_name, salary from employees where last_name = 'KING'; 안됨
		(ex) select last_name, salary from employees where last_name = 'King'; 됨  <- ' '는 대소문자를 가린다
		(ex) select last_name, salary from employees where last_name like 'K%';     <- 대문자K로 시작하는 사람들 (대소문자 가림)
		(ex) select last_name, salary from employees where last_name like '%r';      <- 소문자 r로 끝나는 사람들 (대소문자 가림)    
		(ex) select last_name, salary from employees where last_name like '%o%';   <- 중간에 0들어간 사람
		(ex) select last_name, salary from employees where last_name like '%';       <- 전부다
		(ex) select last_name, salary from employees where last_name like 'K___';    <- 언더바3개 (언더바는 내가 모르는데 1칸짜리	
		(ex) select last_name, salary from employees where last_name like '_o%';    <- 두번째가 0인 사람 조회

		(4) is null : null 값 검색
		(ex) select last_name, employee_id commision_pst from employees where commission_pct is null;

		(4-2) NVL(null value language)  
		(ex) NVL(이걸 출력하는데, 널이면 이 밸류로 출력해줘)
		(ex2) select last_name, NVL(commission_pct, 0) from employees
		(ex3) NVL2(출력할 칼럼명, NOT NULL일 때 출력값, NULL일 때 출력값)   <- select문이니까 안바뀌고 조회만 해오는 것 

		
		#논리 조건 연산자
		(1) AND
		(ex) select last_name, salary from employees where (salary >= 5000) and (salary <= 7000);
		# between은 무조건 하한과 상한 포함하는데 and는 초과 미만 선택 가능

		(2) OR 
		(ex) select last_name, salary from employees where (salary <= 5000) or (salary >= 7000);

		(3) NOT : 뒤에오는 조건이 False면 True로 True면 False로 바꿔줌
		(ex) select employee_id, last_name, manager_id  from employees where manager_id not in (100, 101, 102);  <-널값은 연산이 되지않음
									널을 찾는 방법은 is null 이 유일함
			- not in
			- not like
			- not between A and B
			- is not null
		

		#연산자 우선순위
		NOT -> AND -> OR (범위 좁히는 순으로 하는 거) // 먼저하고 싶으면 괄호 먼저 하면 괄호가 먼저 됨

		### value 중 문자! 날짜! 는 ' '로 감싸줘야함 

		select last_name, salary from employees order by 1;  (조회한 칼럼 num1) 디폴트가 오름차순 
		select last_name, salary from employees order by 2;  (조회한 컬럼 num2) 디폴트가 오름차순

----------------------------------------------------------------------------------------------------------

	#order by 칼럼명 limit <- 오라크렝선 안됨

----------------------------------------------------------------------------------------------------------

		# 집계(집계)함수 SUM() , AVG(), MAX(), MIN(), COUNT(), 분산=VARIANCE(), 표준편차=STDDEV() 평균으로부터 얼마나 분포되있는지 확인
		특징: 그룹당 하나의 결과를 출력해준다.
				NULL 값은 무시하고 연산한다. // 근데 카운트는 *를 썼을 때 NULL을 포함해서 연산한다.
				2회까지 중첩해서 쓸 수 있다.
				count()는 뭘 넣어도 될 때가 많아서 *가 넣는 편
				count()는 행의 수를 센다.
				select (sum(salary)*sum(commission_pct)) as sumsum, (avg(salary)*avg(commission_pct)*107) as avgavg, stddev(salary) from employees;

----------------------------------------------------------------------------------------------------------

	#group by절 
		(그룹 기준 여러개 가능) select department_id, job_id from employees group by department_id, job_id;
		#having절 (having을 group by보다 먼저 써도 쿼리문 동작은 함)
				


	단일 값에대한 조건은 where
	그룹에 대한 조건은 having

	select job_id, salary from where job_id != '%REP%'

	select count(manager_id) from employees group by manager_id;

	select min(salary) from employees where manager_id is not null group by manager_id having min(salary) >= 5000 order by 1 desc;
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<< select에서 불러올 칼럼 (집계함수 적용된거랑 그룹바이 해빙에 있는 조건 칼럼이랑 맞아야 함!!!!!!!!!!!!!!!!)


----------------------------------------------------------------------------------------------------------
	limit 절 <> rownum (서브쿼리로 오덜바이 해주고 rownum)

	LIMIT는 쿼리가 ORDER BY 절까지 모두 실행 후 해당 결과에서 원하는 행의 데이터를 가져오는 것이며, ROWNUM은 쿼리가 완전히 수행되지 않은 원 데이터의 정렬순서대로 번호를 매기기 때문에 전혀 다른 결과가 출력된다.
	오라클에서 LIMIT와 동일한 결과를 얻기 위해서는 SELECT절로 한번 감싼후에 ROWNUM으로 조건을 주면 LIMIT와 동일한 결과가 출력된다.

	select name
	from (select * from animal_ins order by datetime)
	where rownum=1;



	SELECT o.ANIMAL_ID, o.ANIMAL_TYPE, o.NAME 
	from ANIMAL_INS i, ANIMAL_OUTS o 
	where i.ANIMAL_ID = o.ANIMAL_ID
	and i.SEX_UPON_INTAKE like in('Intact%') 
	and (o.SEX_UPON_OUTCOME like in('Spayed%') or o.SEX_UPON_OUTCOME like ('Neutered%'));


	select i.NAME, i.DATETIME from (SELECT i.NAME, i.DATETIME, o.DATETIME 
	from ANIMAL_INS i, ANIMAL_OUTS o 
	where i.ANIMAL_ID = o.ANIMAL_ID(+) order by 2)
	where rownum =1;



