# 계정 관리
	# 계정 생성
		- mysql : CREATE USER (계정명)@(접속위치) 
				  IDENTIFITED BY (비밀번호);
		- oracle : CREATE USER (계정명) 
				   IDENTIFIED BY (비밀번호);
	# 계정 삭제
		- mysql : DROP USER (계정명)@(접속위치);
		- oracle : DROP DATABASE (DB명); 
----------------------------------------------------------------------------------------------------------

# 테이블 관리
	# 테이블 생성
		- mysql : CRSATE TABLE 
		- oracle :   

	# 테이블 수정
		- mysql : 
		- oracle : 

	# 테이블 삭제
		- mysql : 
		- oracle : 
----------------------------------------------------------------------------------------------------------




데이터 베이스 객체

	테이블
	뷰
	시퀀스

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

권한부여 (DCL)

system 계정 / 비번은 설치할 때 그 비번

계정 생성 : create user 계정이름   #유저생성
              identified by 비번;      #비번지정
	(막생성했을 땐 접속 안됨 권한줘야함)

권한부여 : grant 권한이름 to 계정이름;  /  grant connect to project;  #접속권한 부여
	                                        grant resource to project;
	  			      grant create table to project;  #테이블 생성 권한 부여

	  grant 권한 on 테이블 to 사용자; # 관리자가 사용자에게 테이블에 대한 권한을 부여

권한회수 : revoke 권한이름 from 계정이름;
	  revoke 권한 on 테이블 from 사용자;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

데이터타입 
	char : 들어오는 데이터의 개수가 일정할 땐 캐릭터 쓰는 것이 좋다.
	varchar : 들어오는 데이터의 크기를 한 번 읽기는 하지만 저장공간 아낄 수 있음
	varchar2 : 2는 메모리 성능을 조금 더 보완한 것이다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

테이블 생성
	create table 테이블명(컬럼명1 테이터타입, 
	컬럼명2 테이터타입(데이터크기),
	...
	컬럼명10 데이터타입)

	create table member(
	id varchar2(10), 
	pw varchar2(10),
	name varchar2(10),
	age number(3)
	)

테이블 생성2 (as 사용)
	create table dep90
	as
	select 문 <- 셀럭으로 조회되는 내용으로 만들어 줌




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


테이블 삭제
	drop table 테이블명

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
한번에 여러 명령 실행하는 방법   (ed창 처럼 쓰는 방법)   
 // 이 쿼리문 가지고 있으면 어느 디비에 가지고 있어도 실행 됨.  // 스크립트 문

save 파일명.sql  
-> 해당 파일명 경로 찾아서 파일 우클릭 -> 편집
메모장에서 여러 sql문 한번에 입력 (이땐 세미콜론 써줘야함)
그리고 저장
cmd 창에서 @파일명.sql
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

이렇게 스크립트를 쌓아하는게 업무처리 정석이다.

drop table member;

create table member(
id varchar2(10), 
pw varchar2(10),
name varchar2(10),
age number(3),
money number(10) default 10000,
);

insert into member values ('yg1', '123', 'yg1', 21);
insert into member values ('yg2', '123', 'yg2', 22);
insert into member values ('yg3', '123', 'yg3', 23);


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

truncate table 테이블명; <- 테이블 지우는 건데 롤백 안됨
(dml은 작업단위가 row고 ddl은 작업단위가 객체이다. 객체는 테이블, 칼럼 등)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

VIEW (원테이블 정보 변경되면 뷰의 정보도 변경됨)   <- view는 select으로 조회 됨

	create view 테이블명(vu)
	as
	select 문

	








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

alter 데이터의 구조를 변경하는 명령어

(추가)	alter table 테이블명
	add (칼럼명 데이터형(갯수))

(수정)	alter table 테이블명
	modify (칼럼명 데이터형(갯수))   (문자는 맥스까지 줄이기 가능, 숫자는 비워져야 가능한듯 (정밀도, 스케일)) 정밀도는 소수점 앞 스케일은 소수

(삭제)     alter table 테이블명
	drop column 컬럼명;


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

제약조건
pk (primary key)
fk (foreign key)
uk (unique) : 중복을 방지한다
nn (not null) : 


	SQL> create table member(
	2  id varchar(10),
	3  pw varchar(10,
	4  name varchar(10),
	5  money number(10),
	6  constraint 제약조건이름 제약조건 (컬럼명)    
	7  )
	         <	제약조건 이름이 매우 중요하다>  어떤 제약조건이 오류인지 알기 위해서 

테이블 레벨 단위에서 제약조건 설정
	SQL> create table member(
	2  id varchar(10),
	3  pw varchar(10,
	4  name varchar(10),
	5  money number(10),
	6  constraint member_id_pk primary key(id)
	7  )

컬럼레벨 단위에서 제약조건 설정  -> 주의! 이 제약조건은 id 제약조건에 붙은 거라서 컬럼명 부분 없음  // not null 은 컬럼 레벨에서만 가능//제약조건 
	SQL> create table member(												이름도 안씀
	2  id varchar(10) constraint member_id_pk primary key,
	3  pw varchar(10,
	4  name varchar(10),
	5  money number(10),
	7  )



check / foreign references

	create table member(
	id varchar(10) constraint member_id_pk primary key,
	pw varchar(10,
	name varchar(10),
	money number(10) check (money>0),     <-양수만 입력가능하게 설정  /check가 사용자 지정함수
	dep_id number(4),
	constraint member_dep_id_fk foreign key(dep_id)
	references departments(department_id)


create table test(
a number(5) constraint test_a_pk primary key,
b number(5) not null,
c number(5) unique,
d number(5), check (d in (0,1))
)
 -같음- 선언부가 다름
create table test(
a number(5),
b number(5) not null,
c number(5),
d number(5),
constraint test_a_pk primary key(a),
constraint test_c_uk unique (c),
constraint test_d_ck check (d in (0, 1))
)

----

create table test2(
e number(5) constraint test_e_pk primary key,     <- 열레벨 우선키 설정
f number(5) not null,
a number(5) references test(a)    <- 열레벨 외래키 설명
)
 -같음- 선언부가 다름
create table test2(
e number(5) constraint test_e_pk primary key,
f number(5) not null,
a number(5), 
constraint test2_a_fk foreign key(a)
references test(a)
)

------


밖에서 외래키 설정한는 방법
	ALTER TABLE 테이블명
    		ADD CONSTRAINT 외래키명 FOREIGN KEY (칼럼명)
        		       REFERENCES 테이블명 (칼럼명); <-?

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

create table dept(
deptno number(2),
dname varchar2(14) not null,
loc varchar2(13) not null,
constraint dept_no_pk primary key(deptno)
)

create table emp(
empno number(4),
ename varchar2(10) not null,
gender char(10) not null,
job varchar2(9) not null,
mgr number(4),
hiredate date not null,
sal number(7,2) not null,
comm number(7,2) not null,
deptno number(2),
constraint emp_no_pk primary key(empno),
constraint emp_deptno_fk foreign key(deptno) references dept(deptno),
constraint emp_gender_ck check (gender in ('MAN', 'WOMAN'))
)



-cascasde-  참조하는 데이터 
drop table dept cascade constraints;
drop table empt cascade constraints;



----------------------------------------------------------------------------------------------------------------------------------------------------------------
테이블, 뷰, 시퀀스, 인덱스, 동의어 <- 객체


시퀀스
create sequence 시퀀스명
MINVALUE -- 시퀀스가 시작되는 최초의 숫자
MAXVALUE --시퀀스가 끝나는 최대 숫자
INCREMENT BY -- 시퀀스가 증가되는 단위
START WITH -- 시퀀스 생성이 시작되는 값
NOCACHE  -- 캐시를 사용하지 않음
NOORDER  --요청되는 순서대로 값을 생성하지 않음
NOCYCLE  --초기값부터 다시 시작하지 않음

create sequence mem_ID_SEQ
start with 100
increment by 1
minvalue 100
maxvalue 9999
nocycle;

----------------------------------------------------------------------------------------------------------------------------------------------------------------

select sysdate from dual;  <- 현재 날짜 확인하는 방법  // dual이라는 가상 테이블 사용


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
insert 

	insert into 테이블명(컬럼명)  <- 컬럼명은 안적으면 모든 컬럼 개수 맞춰서 적어야하고 컬럼명 적으면 컬럼명 개수만큼 컬럼값 적어야함
	values (각 칼럼에 해당 값)

컬럼무결성 : 데이터 타입이 맞아야 데이터가 삽입이 됨

!! 다른 테이블에서 행 복사 삽입 !!
	insert into 테이블명 selec문       <- 주의, 인설트 절의 열 수와 서브쿼리문의 열수를 일치시켜야한다. (select 문이 서브쿼리문)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
update 
	
	update 테이블명
	set 칼럼명 = 데이터
	(where department_id = 70) <- 웨어 안쓰면 전체 바뀌니까 웬만하면 적기

       병행제어
	-로킹
	-타임스탬프
	-낙관적 병행제어
	-다중버전 병행제어
	  (연쇄복귀?) : 두개 이상의 Transaction이 수행되던중 한개의 Transaction이 취소될 때 나머지 다른 Transaction도 연쇄적으로 취소되는 현상
	  두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생
	  한 트랜잭션이 데이터를 갱신한 다음 실패하여 Rollback 연산을 수행하는 과정에서 갱신과 Rollback 연산을 실행하고 있는 사이에 
	  해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제
	  같은 자원을 사용하는 두개의 트랜잭션 중 한 개의 트랜잭션이 성공적으로 일을 수행하였다 하더라도 
	  다른 트랜잭션이 처리하는 과정에서 실패하게 되면 두 개의 트랜잭션 모두가 복귀되는 현상

	update employees set salary = (select max(salary) from employees where department_id = 50) where department_id = 70;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
delete

	delete (from) 테이블명 <- from은 생략가능
	(where department_id = 270;)   <- 웨어 안쓰면 전체 바뀌니까 웬만하면 적기

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------

오라클에서 오토인크리먼트 구현

시퀀스 만들기
CREATE SEQUENCE MEM_MEMID_SEQ
INCREMENT BY 1 -- 증가값 : 1
START WITH 100 -- 시작값 : 100
MINVALUE 100 -- 최솟값 : 100
MAXVALUE 9999 -- 최댓값 : 9999
NOCYCLE;

시퀀스 넘기기
select mem_id_seq.NextVAL
from dual

현재 시퀀스 조회
select mem_id_seq.currval
from dual


insert into member(mem_id, id, pw, name)
values (mem_id_seq.nextval, 'yg', '1234', 'yun9yu');

입력값을 넥스트 벨류로 넣으면 됨


















